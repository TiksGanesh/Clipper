-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enums
CREATE TYPE subscription_status AS ENUM ('trial', 'active', 'past_due', 'canceled', 'expired');
CREATE TYPE booking_status AS ENUM ('confirmed', 'completed', 'canceled', 'no_show');

-- Shops table
CREATE TABLE shops (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE RESTRICT,
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(20) NOT NULL,
    address TEXT,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT unique_owner UNIQUE (owner_id)
);

-- Barbers table
CREATE TABLE barbers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    shop_id UUID NOT NULL REFERENCES shops(id) ON DELETE RESTRICT,
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    is_active BOOLEAN NOT NULL DEFAULT true,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enforce max 2 ACTIVE barbers per shop (excluding soft-deleted)
CREATE OR REPLACE FUNCTION enforce_max_barbers()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT COUNT(*) 
        FROM barbers 
        WHERE shop_id = NEW.shop_id 
        AND is_active = true 
        AND deleted_at IS NULL) >= 2 THEN
        RAISE EXCEPTION 'Maximum 2 active barbers allowed per shop';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_max_barbers
BEFORE INSERT OR UPDATE ON barbers
FOR EACH ROW
WHEN (NEW.deleted_at IS NULL)
EXECUTE FUNCTION enforce_max_barbers();

-- Services table
CREATE TABLE services (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    shop_id UUID NOT NULL REFERENCES shops(id) ON DELETE RESTRICT,
    name VARCHAR(255) NOT NULL,
    duration_minutes INTEGER NOT NULL CHECK (duration_minutes > 0 AND duration_minutes <= 480),
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    is_active BOOLEAN NOT NULL DEFAULT true,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Bookings table (NEVER delete - archive only)
CREATE TABLE bookings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    shop_id UUID NOT NULL REFERENCES shops(id) ON DELETE RESTRICT,
    barber_id UUID NOT NULL REFERENCES barbers(id) ON DELETE RESTRICT,
    service_id UUID NOT NULL REFERENCES services(id) ON DELETE RESTRICT,
    customer_name VARCHAR(255) NOT NULL,
    customer_phone VARCHAR(20) NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    status booking_status NOT NULL DEFAULT 'confirmed',
    is_walk_in BOOLEAN NOT NULL DEFAULT false,
    notes TEXT,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Prevent overlapping bookings (exclude soft-deleted)
CREATE OR REPLACE FUNCTION check_booking_overlap()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.deleted_at IS NOT NULL THEN
        RETURN NEW;
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM bookings
        WHERE barber_id = NEW.barber_id
        AND status IN ('confirmed', 'completed')
        AND deleted_at IS NULL
        AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID)
        AND (
            (NEW.start_time >= start_time AND NEW.start_time < end_time)
            OR (NEW.end_time > start_time AND NEW.end_time <= end_time)
            OR (NEW.start_time <= start_time AND NEW.end_time >= end_time)
        )
    ) THEN
        RAISE EXCEPTION 'Booking time overlaps with existing booking for this barber';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_booking_overlap
BEFORE INSERT OR UPDATE ON bookings
FOR EACH ROW
EXECUTE FUNCTION check_booking_overlap();

-- Subscriptions table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    shop_id UUID NOT NULL REFERENCES shops(id) ON DELETE RESTRICT,
    razorpay_subscription_id VARCHAR(255) UNIQUE,
    razorpay_plan_id VARCHAR(255),
    status subscription_status NOT NULL DEFAULT 'trial',
    trial_ends_at TIMESTAMPTZ,
    current_period_start TIMESTAMPTZ,
    current_period_end TIMESTAMPTZ,
    canceled_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT unique_shop_subscription UNIQUE (shop_id)
);

-- Indexes (exclude soft-deleted records)
CREATE INDEX idx_shops_active ON shops(owner_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_barbers_shop_active ON barbers(shop_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_services_shop_active ON services(shop_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_bookings_shop_active ON bookings(shop_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_bookings_barber_active ON bookings(barber_id, start_time) WHERE deleted_at IS NULL;
CREATE INDEX idx_subscriptions_shop_active ON subscriptions(shop_id) WHERE deleted_at IS NULL;

-- Views for active records only
CREATE VIEW active_shops AS 
SELECT * FROM shops WHERE deleted_at IS NULL;

CREATE VIEW active_barbers AS 
SELECT * FROM barbers WHERE deleted_at IS NULL;

CREATE VIEW active_services AS 
SELECT * FROM services WHERE deleted_at IS NULL;

CREATE VIEW active_bookings AS 
SELECT * FROM bookings WHERE deleted_at IS NULL;

-- Updated_at triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_shops_updated_at BEFORE UPDATE ON shops FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_barbers_updated_at BEFORE UPDATE ON barbers FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_services_updated_at BEFORE UPDATE ON services FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_bookings_updated_at BEFORE UPDATE ON bookings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


-- ============================================================================
-- ROW LEVEL SECURITY POLICIES
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE shops ENABLE ROW LEVEL SECURITY;
ALTER TABLE barbers ENABLE ROW LEVEL SECURITY;
ALTER TABLE services ENABLE ROW LEVEL SECURITY;
ALTER TABLE bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- SHOPS TABLE POLICIES
-- ============================================================================

-- Shop owners can read their own shop
CREATE POLICY "shop_owners_read_own_shop"
ON shops FOR SELECT
TO authenticated
USING (owner_id = auth.uid());

-- Shop owners can update their own shop
CREATE POLICY "shop_owners_update_own_shop"
ON shops FOR UPDATE
TO authenticated
USING (owner_id = auth.uid())
WITH CHECK (owner_id = auth.uid());

-- Shop owners can insert their own shop (one-time setup)
CREATE POLICY "shop_owners_insert_own_shop"
ON shops FOR INSERT
TO authenticated
WITH CHECK (owner_id = auth.uid());

-- Admins can read all shops
CREATE POLICY "admins_read_all_shops"
ON shops FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM auth.users
        WHERE id = auth.uid()
        AND raw_user_meta_data->>'role' = 'admin'
    )
);

-- ============================================================================
-- BARBERS TABLE POLICIES
-- ============================================================================

-- Shop owners can read their shop's barbers
CREATE POLICY "shop_owners_read_own_barbers"
ON barbers FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = barbers.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Shop owners can insert barbers for their shop
CREATE POLICY "shop_owners_insert_own_barbers"
ON barbers FOR INSERT
TO authenticated
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = barbers.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Shop owners can update their shop's barbers
CREATE POLICY "shop_owners_update_own_barbers"
ON barbers FOR UPDATE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = barbers.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = barbers.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- ============================================================================
-- SERVICES TABLE POLICIES
-- ============================================================================

-- Shop owners can read their shop's services
CREATE POLICY "shop_owners_read_own_services"
ON services FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = services.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Shop owners can insert services for their shop
CREATE POLICY "shop_owners_insert_own_services"
ON services FOR INSERT
TO authenticated
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = services.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Shop owners can update their shop's services
CREATE POLICY "shop_owners_update_own_services"
ON services FOR UPDATE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = services.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = services.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- ============================================================================
-- BOOKINGS TABLE POLICIES
-- ============================================================================

-- Shop owners can read their shop's bookings
CREATE POLICY "shop_owners_read_own_bookings"
ON bookings FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = bookings.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Shop owners can insert bookings for their shop (walk-ins)
CREATE POLICY "shop_owners_insert_own_bookings"
ON bookings FOR INSERT
TO authenticated
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = bookings.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Shop owners can update their shop's bookings
CREATE POLICY "shop_owners_update_own_bookings"
ON bookings FOR UPDATE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = bookings.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = bookings.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Customers (anonymous users) can ONLY insert bookings
-- No authentication required for customer bookings
CREATE POLICY "customers_insert_bookings"
ON bookings FOR INSERT
TO anon
WITH CHECK (true);

-- ============================================================================
-- SUBSCRIPTIONS TABLE POLICIES
-- ============================================================================

-- Shop owners can read their own subscription
CREATE POLICY "shop_owners_read_own_subscription"
ON subscriptions FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM shops
        WHERE shops.id = subscriptions.shop_id
        AND shops.owner_id = auth.uid()
        AND shops.deleted_at IS NULL
    )
);

-- Only system/webhooks can insert/update subscriptions
-- Shop owners cannot directly modify subscriptions
CREATE POLICY "service_role_manage_subscriptions"
ON subscriptions FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- ============================================================================
-- ADMIN POLICIES (cross-cutting)
-- ============================================================================

-- Admins can read all barbers
CREATE POLICY "admins_read_all_barbers"
ON barbers FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM auth.users
        WHERE id = auth.uid()
        AND raw_user_meta_data->>'role' = 'admin'
    )
);

-- Admins can read all services
CREATE POLICY "admins_read_all_services"
ON services FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM auth.users
        WHERE id = auth.uid()
        AND raw_user_meta_data->>'role' = 'admin'
    )
);

-- Admins can read all bookings
CREATE POLICY "admins_read_all_bookings"
ON bookings FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM auth.users
        WHERE id = auth.uid()
        AND raw_user_meta_data->>'role' = 'admin'
    )
);

-- Admins can read all subscriptions
CREATE POLICY "admins_read_all_subscriptions"
ON subscriptions FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM auth.users
        WHERE id = auth.uid()
        AND raw_user_meta_data->>'role' = 'admin'
    )
);


-- Ensure pgcrypto is available for gen_random_uuid()
create extension if not exists pgcrypto;

-- Create working_hours table
create table if not exists public.working_hours (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid not null references public.shops(id) on delete cascade,
  day_of_week smallint not null check (day_of_week between 0 and 6),
  open_time time,
  close_time time,
  is_closed boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create unique index if not exists working_hours_shop_day_idx
  on public.working_hours (shop_id, day_of_week);

-- Enforce max 2 barbers per shop via trigger
create or replace function public.enforce_max_two_barbers()
returns trigger as $$
begin
  if ( (select count(*) from public.barbers where shop_id = new.shop_id and deleted_at is null) >= 2 ) then
    raise exception 'Maximum 2 barbers per shop';
  end if;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists trg_enforce_max_two_barbers on public.barbers;
create trigger trg_enforce_max_two_barbers
before insert on public.barbers
for each row execute function public.enforce_max_two_barbers();

-- Basic RLS policies (require authentication, owner access)
alter table public.shops enable row level security;
alter table public.barbers enable row level security;
alter table public.services enable row level security;
alter table public.working_hours enable row level security;

-- Assume auth.uid() is the owner_id for shops
create policy shops_owner_select on public.shops
  for select using (owner_id = auth.uid() and deleted_at is null);
create policy shops_owner_insert on public.shops
  for insert with check (owner_id = auth.uid());
create policy shops_owner_update on public.shops
  for update using (owner_id = auth.uid()) with check (owner_id = auth.uid());

-- Barbers/services/working_hours scoped by shop ownership
create policy barbers_owner_all on public.barbers
  for all using (
    exists (
      select 1 from public.shops s where s.id = barbers.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = barbers.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  );

create policy services_owner_all on public.services
  for all using (
    exists (
      select 1 from public.shops s where s.id = services.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = services.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  );

create policy working_hours_owner_all on public.working_hours
  for all using (
    exists (
      select 1 from public.shops s where s.id = working_hours.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = working_hours.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  );

-- Additional constraints for services
alter table public.services
  add constraint services_duration_positive check (duration_minutes > 0);
alter table public.services
  add constraint services_price_nonnegative check (price >= 0);

-- Ensure pgcrypto is available for gen_random_uuid()
create extension if not exists pgcrypto;

-- ========================================
-- SHOPS TABLE
-- ========================================
create table if not exists public.shops (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  phone text not null,
  address text,
  deleted_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Ensure one shop per owner (including soft-deleted)
create unique index if not exists unique_owner on public.shops(owner_id);

-- ========================================
-- BARBERS TABLE
-- ========================================
create table if not exists public.barbers (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid not null references public.shops(id) on delete cascade,
  name text not null,
  phone text,
  is_active boolean not null default true,
  deleted_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- ========================================
-- SERVICES TABLE
-- ========================================
create table if not exists public.services (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid not null references public.shops(id) on delete cascade,
  name text not null,
  duration_minutes int not null,
  price numeric(10,2) not null default 0,
  is_active boolean not null default true,
  deleted_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- ========================================
-- WORKING HOURS TABLE
-- ========================================
create table if not exists public.working_hours (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid not null references public.shops(id) on delete cascade,
  day_of_week smallint not null check (day_of_week between 0 and 6),
  open_time time,
  close_time time,
  is_closed boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create unique index if not exists working_hours_shop_day_idx
  on public.working_hours (shop_id, day_of_week);

-- ========================================
-- BOOKINGS TABLE
-- ========================================
create table if not exists public.bookings (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid not null references public.shops(id) on delete cascade,
  barber_id uuid not null references public.barbers(id) on delete cascade,
  service_id uuid not null references public.services(id) on delete restrict,
  customer_name text not null,
  customer_phone text not null,
  start_time timestamptz not null,
  end_time timestamptz not null,
  status text not null default 'confirmed' check (status in ('confirmed', 'completed', 'cancelled', 'no_show')),
  is_walk_in boolean not null default false,
  notes text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Prevent double booking: one barber can't have overlapping appointments
create unique index if not exists bookings_no_overlap_idx
  on public.bookings (barber_id, tstzrange(start_time, end_time, '[)'))
  where status != 'cancelled';

-- ========================================
-- SUBSCRIPTIONS TABLE (for Razorpay)
-- ========================================
create table if not exists public.subscriptions (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid not null references public.shops(id) on delete cascade unique,
  razorpay_subscription_id text unique,
  razorpay_plan_id text,
  status text not null default 'trial' check (status in ('trial', 'active', 'past_due', 'cancelled', 'expired')),
  trial_ends_at timestamptz,
  current_period_start timestamptz,
  current_period_end timestamptz,
  cancelled_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- ========================================
-- TRIGGERS
-- ========================================

-- Enforce max 2 barbers per shop via trigger
create or replace function public.enforce_max_two_barbers()
returns trigger as $$
begin
  if ( (select count(*) from public.barbers where shop_id = new.shop_id and deleted_at is null) >= 2 ) then
    raise exception 'Maximum 2 barbers per shop';
  end if;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists trg_enforce_max_two_barbers on public.barbers;
create trigger trg_enforce_max_two_barbers
before insert on public.barbers
for each row execute function public.enforce_max_two_barbers();

-- ========================================
-- ROW LEVEL SECURITY (RLS)
-- ========================================

alter table public.shops enable row level security;
alter table public.barbers enable row level security;
alter table public.services enable row level security;
alter table public.working_hours enable row level security;
alter table public.bookings enable row level security;
alter table public.subscriptions enable row level security;

-- SHOPS: Owner can do everything
create policy shops_owner_select on public.shops
  for select using (owner_id = auth.uid() and deleted_at is null);
create policy shops_owner_insert on public.shops
  for insert with check (owner_id = auth.uid());
create policy shops_owner_update on public.shops
  for update using (owner_id = auth.uid()) with check (owner_id = auth.uid());

-- BARBERS: Owner (via shop) can manage
create policy barbers_owner_all on public.barbers
  for all using (
    exists (
      select 1 from public.shops s where s.id = barbers.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = barbers.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  );

-- SERVICES: Owner (via shop) can manage
create policy services_owner_all on public.services
  for all using (
    exists (
      select 1 from public.shops s where s.id = services.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = services.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  );

-- WORKING HOURS: Owner (via shop) can manage
create policy working_hours_owner_all on public.working_hours
  for all using (
    exists (
      select 1 from public.shops s where s.id = working_hours.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = working_hours.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  );

-- BOOKINGS: Owner can view/manage their shop's bookings
create policy bookings_owner_all on public.bookings
  for all using (
    exists (
      select 1 from public.shops s where s.id = bookings.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = bookings.shop_id and s.owner_id = auth.uid() and s.deleted_at is null
    )
  );

-- BOOKINGS: Customers (unauthenticated) can create bookings
create policy bookings_customer_insert on public.bookings
  for insert with check (true); -- Anyone can create a booking

-- SUBSCRIPTIONS: Owner can view their subscription
create policy subscriptions_owner_all on public.subscriptions
  for all using (
    exists (
      select 1 from public.shops s where s.id = subscriptions.shop_id and s.owner_id = auth.uid()
    )
  ) with check (
    exists (
      select 1 from public.shops s where s.id = subscriptions.shop_id and s.owner_id = auth.uid()
    )
  );

-- ========================================
-- CONSTRAINTS
-- ========================================

alter table public.services
  add constraint if not exists services_duration_positive check (duration_minutes > 0);
alter table public.services
  add constraint if not exists services_price_nonnegative check (price >= 0);

-- Fix the foreign key constraint to not require auth.users read permission
-- Drop and recreate without the FK, or grant permissions

-- Grant SELECT on auth.users to authenticated users (for FK validation)
grant usage on schema auth to authenticated;
grant select on auth.users to authenticated;  